import heapq
from collections import Counter
import matplotlib.pyplot as plt
import networkx as nx
import random

class HuffmanNode:
    def __init__(self, symbol=None, frequency=0, left=None, right=None):
        self.symbol = symbol
        self.frequency = frequency
        self.left = left
        self.right = right
    
    def __lt__(self, other):
        return self.frequency < other.frequency
    
    def is_leaf(self):
        return self.symbol is not None

class HuffmanCoding:
    def __init__(self, frequencies):
        self.frequencies = frequencies
        self.root = None
        self.codes = {}
        self.construction_steps = []
    
    def build_tree(self):
        heap = []
        for symbol, freq in self.frequencies.items():
            node = HuffmanNode(symbol=symbol, frequency=freq)
            heapq.heappush(heap, node)
        self.construction_steps.append(f"Initial: {[(n.symbol, n.frequency) for n in heap]}")
        step_num = 1
        while len(heap) > 1:
            left = heapq.heappop(heap)
            right = heapq.heappop(heap)
            merged = HuffmanNode(frequency=left.frequency + right.frequency, left=left, right=right)
            heapq.heappush(heap, merged)
            self.construction_steps.append(
                f"Step {step_num}: Combine {left.symbol if left.symbol else f'Internal({left.frequency})'}({left.frequency}) + "
                f"{right.symbol if right.symbol else f'Internal({right.frequency})'}({right.frequency}) = Internal({merged.frequency})"
            )
            step_num += 1
        self.root = heap[0]
        return self.root
    
    def generate_codes(self, node=None, code=""):
        if node is None:
            node = self.root
        if node.is_leaf():
            self.codes[node.symbol] = code if code else "0"
            return
        if node.left:
            self.generate_codes(node.left, code + "0")
        if node.right:
            self.generate_codes(node.right, code + "1")
    
    def print_analysis(self):
        print("=" * 70)
        print("HUFFMAN CODING ANALYSIS")
        print("=" * 70)
        print("\n1. INPUT FREQUENCIES:")
        print("-" * 50)
        for symbol in sorted(self.frequencies.keys()):
            print(f"   Symbol {symbol}: {self.frequencies[symbol]}")
        print(f"   Total: {sum(self.frequencies.values())}")
        print("\n2. TREE CONSTRUCTION:")
        print("-" * 50)
        for step in self.construction_steps:
            print(f"   {step}")
        print("\n3. HUFFMAN CODES:")
        print("-" * 50)
        for symbol in sorted(self.codes.keys()):
            print(f"   {symbol}: {self.codes[symbol]} (length: {len(self.codes[symbol])})")
        avg_len, total_freq, weighted = self.calculate_average_length()
        print("\n4. AVERAGE CODE LENGTH:")
        print("-" * 50)
        print(f"   Σ(freq × length) = {weighted}")
        print(f"   Σ(freq) = {total_freq}")
        print(f"   Average = {avg_len:.4f} bits/symbol")
        return avg_len
    
    def calculate_average_length(self):
        total_freq = sum(self.frequencies.values())
        weighted_sum = sum(self.frequencies[symbol] * len(self.codes[symbol]) for symbol in self.codes)
        avg_length = weighted_sum / total_freq
        return avg_length, total_freq, weighted_sum

def compare_with_fixed_length(frequencies, huffman_avg_length):
    import math
    num_symbols = len(frequencies)
    fixed_length = math.ceil(math.log2(num_symbols))
    print("\n5. FIXED-LENGTH ENCODING:")
    print("-" * 50)
    print(f"   Number of symbols: {num_symbols}")
    print(f"   Bits per symbol: ⌈log₂({num_symbols})⌉ = {fixed_length}")
    print("\n6. COMPARISON:")
    print("-" * 50)
    print(f"   Huffman: {huffman_avg_length:.4f} bits/symbol")
    print(f"   Fixed: {fixed_length} bits/symbol")
    print(f"   Improvement: {fixed_length - huffman_avg_length:.4f} bits/symbol")
    print(f"   Compression: {(1 - huffman_avg_length/fixed_length) * 100:.2f}%")
    total_freq = sum(frequencies.values())
    total_huffman = huffman_avg_length * total_freq
    total_fixed = fixed_length * total_freq
    print("\n7. TOTAL ENCODING COST:")
    print("-" * 50)
    print(f"   Huffman: {total_huffman:.0f} bits")
    print(f"   Fixed: {total_fixed} bits")
    print(f"   Saved: {total_fixed - total_huffman:.0f} bits")

def visualize_huffman_tree_networkx(root):
    G = nx.DiGraph()
    labels = {}
    pos = {}

    def add_edges(node, parent=None, label='', xpos=0, ypos=0, delta_x=1):
        node_id = id(node)
        if node.is_leaf():
            node_label = f"{node.symbol}({node.frequency})\nCode: {label}"
        else:
            node_label = f"Internal({node.frequency})" if parent else f"Root({node.frequency})"
        G.add_node(node_id)
        labels[node_id] = node_label
        pos[node_id] = (xpos, ypos)
        if parent is not None:
            G.add_edge(parent, node_id, weight=label[-1] if label else "")
        if node.left:
            add_edges(node.left, node_id, label + '0', xpos - delta_x, ypos - 1, delta_x / 2)
        if node.right:
            add_edges(node.right, node_id, label + '1', xpos + delta_x, ypos - 1, delta_x / 2)

    add_edges(root, None, '', 0, 0, 2)
    plt.figure(figsize=(10, 6))
    nx.draw(G, pos, with_labels=False, arrows=False, node_color='#90e0ef', node_size=2500)
    nx.draw_networkx_labels(G, pos, labels, font_size=9, font_weight='bold')
    edge_labels = { (u,v): d['weight'] for u,v,d in G.edges(data=True) }
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9)
    plt.title("Huffman Tree Structure (NetworkX)")
    plt.axis('off')
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    frequencies = {'X': 10, 'Y': 15, 'Z': 30, 'W': 45}
    huffman = HuffmanCoding(frequencies)
    huffman.build_tree()
    huffman.generate_codes()
    avg_length = huffman.print_analysis()
    compare_with_fixed_length(frequencies, avg_length)

    # Visualize the Huffman tree using NetworkX + Matplotlib method
    visualize_huffman_tree_networkx(huffman.root)

